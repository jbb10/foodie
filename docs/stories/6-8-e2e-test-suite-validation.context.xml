<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>6</epicId>
    <storyId>8</storyId>
    <title>E2E Test Suite Validation and Regression Coverage</title>
    <status>drafted</status>
    <generatedAt>2025-11-30</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/6-8-e2e-test-suite-validation.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a developer</asA>
    <iWant>all E2E instrumentation tests running successfully with comprehensive coverage</iWant>
    <soThat>we have a reliable regression test suite and accurate test coverage metrics in SonarQube</soThat>
    <tasks>
### Task 1: Test Suite Health Check
- [ ] Run `./gradlew connectedDebugAndroidTest` and document results
- [ ] Identify any failing tests and root cause
- [ ] Fix or document flaky tests
- [ ] Verify all 23 test files execute

### Task 2: Epic 6 User Flow Mapping
- [ ] Document all Epic 6 user flows (Stories 6-1 through 6-7)
- [ ] Map existing instrumentation tests to each flow
- [ ] Identify coverage gaps (flows without tests)
- [ ] Create test coverage matrix

### Task 3: SonarQube Coverage Integration
- [ ] Configure Gradle for instrumentation test coverage (JaCoCo)
- [ ] Run combined coverage report: `./gradlew test connectedDebugAndroidTest jacocoTestReport`
- [ ] Verify coverage data includes instrumentation tests
- [ ] Upload to SonarQube and validate metrics
- [ ] Document any configuration changes

### Task 4: Test Organization Review
- [ ] Review all 23 test files for naming consistency
- [ ] Ensure logical grouping (by screen/feature)
- [ ] Check for duplicate test coverage
- [ ] Refactor if needed for clarity

### Task 5: Test Reliability Validation
- [ ] Run test suite 3 times consecutively
- [ ] Document any flaky tests (inconsistent results)
- [ ] Fix flaky tests (timing issues, state pollution)
- [ ] Verify tests can run in any order

### Task 6: Test Data and Dependencies Audit
- [ ] Review test setup/teardown in all files
- [ ] Verify proper use of Hilt test components
- [ ] Check Health Connect mock/fake usage
- [ ] Ensure no test pollution between tests

### Task 7: Performance Profiling
- [ ] Measure total test suite execution time
- [ ] Identify slowest tests (> 10 seconds)
- [ ] Optimize slow tests if possible
- [ ] Document performance baseline

### Task 8: Coverage Analysis
- [ ] Generate JaCoCo coverage report
- [ ] Analyze line/branch coverage percentages
- [ ] Identify critical uncovered code
- [ ] Document coverage metrics

### Task 9: Regression Test Guide
- [ ] Create `docs/testing/REGRESSION_TESTING.md`
- [ ] Document how to run tests locally
- [ ] Document test suite organization
- [ ] Include troubleshooting guide
- [ ] Document CI/CD integration (if applicable)

### Task 10: Epic 6 Test Summary
- [ ] Update sprint-status.yaml with Story 6-8 completion
- [ ] Document final test count (unit + instrumentation)
- [ ] Document coverage percentage
- [ ] Mark Epic 6 ready for retrospective
    </tasks>
  </story>

  <acceptanceCriteria>
### AC #1: Test Suite Execution
**Given** all 23 instrumentation test files exist
**When** I run `./gradlew connectedDebugAndroidTest`
**Then** all tests execute successfully with 0 failures
**And** test execution completes in under 5 minutes
**And** no flaky tests (tests pass consistently on multiple runs)

### AC #2: Epic 6 User Flow Coverage
**Given** Epic 6 includes 7 completed stories (6-1 through 6-7)
**When** I map instrumentation tests to user flows
**Then** every critical user flow has test coverage:
- User profile management (6-1)
- Energy balance calculations (6-2 through 6-5)
- Dashboard display and real-time updates (6-6)
- Historical day navigation (6-7)
**And** test coverage matrix is documented

### AC #3: SonarQube Integration
**Given** instrumentation tests execute successfully
**When** I run `./gradlew test connectedDebugAndroidTest jacocoTestReport sonar`
**Then** SonarQube includes instrumentation test coverage in the report
**And** code coverage percentage reflects both unit and instrumentation tests
**And** coverage metrics are visible in SonarQube dashboard
**And** any gaps in coverage are identified

### AC #4: Regression Test Documentation
**Given** the test suite is stable and comprehensive
**When** I document the regression test strategy
**Then** a test guide explains:
- How to run all tests locally
- How to run specific test suites (unit vs instrumentation)
- How to interpret test results
- How to add new tests following established patterns
**And** CI/CD integration is documented (if applicable)

### AC #5: Test Organization and Naming
**Given** 23 instrumentation test files exist
**When** I review test organization
**Then** all tests follow consistent naming conventions
**And** tests are grouped logically by feature/screen
**And** test method names clearly describe scenarios
**And** no duplicate or redundant test coverage

### AC #6: Test Data and Dependencies
**Given** tests may have external dependencies (Health Connect, permissions)
**When** I review test setup and teardown
**Then** all tests properly initialize required dependencies
**And** tests clean up after themselves (no test pollution)
**And** tests can run in any order (no interdependencies)
**And** mock/fake implementations are used appropriately

### AC #7: Performance Validation
**Given** instrumentation tests run on emulator/device
**When** I measure test execution time
**Then** total test suite execution time &lt; 5 minutes
**And** individual test execution time &lt; 30 seconds
**And** slow tests are identified and optimized if possible

### AC #8: Coverage Gaps Identified
**Given** current test suite coverage is measured
**When** I analyze coverage reports
**Then** any critical uncovered code paths are documented
**And** recommendations are made for additional tests (if needed)
**And** acceptable coverage threshold is defined (e.g., 80% line coverage)
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <artifact>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>Success Criteria</section>
        <snippet>Primary Success Criterion: Speed Validation - Average capture time â‰¤ 5 seconds. Sustained Usage: Still tracking on workdays after 30 days. AI Accuracy: Trust-based validation with manual correction capability.</snippet>
      </artifact>
      <artifact>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Testing Strategy</section>
        <snippet>MVVM architecture with Jetpack Compose UI, Hilt dependency injection. Testing includes unit tests for ViewModels/Repositories, instrumentation tests for UI flows, and integration tests for Health Connect and WorkManager.</snippet>
      </artifact>
      <artifact>
        <path>docs/tech-spec-epic-6.md</path>
        <title>Epic 6 Technical Specification</title>
        <section>Overview</section>
        <snippet>Epic 6 delivers comprehensive caloric deficit tracking by implementing TDEE calculations (BMR + NEAT + Active Energy). Dashboard displays Calories In vs Calories Out with real-time updates via Health Connect integration.</snippet>
      </artifact>
      <artifact>
        <path>docs/development/definition-of-done.md</path>
        <title>Definition of Done</title>
        <section>Testing Requirements</section>
        <snippet>All unit tests passing (100% pass rate), integration tests for critical flows, SonarQube scan with 0 BLOCKER/CRITICAL issues, manual smoke testing on physical device (Pixel 8 Pro Android 16).</snippet>
      </artifact>
      <artifact>
        <path>docs/testing/integration-test-plan.md</path>
        <title>Integration Test Plan</title>
        <section>Test Environment Setup</section>
        <snippet>Comprehensive integration test plan for all 33 user stories across 5 epics. Primary device: Pixel 8 Pro Android 16. Test types: Integration, End-to-End, Edge Case, Performance, Multi-Device.</snippet>
      </artifact>
      <artifact>
        <path>docs/testing/compose-hilt-testing-guide.md</path>
        <title>Compose Hilt Testing Guide</title>
        <section>Testing Patterns</section>
        <snippet>HiltAndroidRule for dependency injection in tests, createComposeRule for UI tests, FakeHealthConnectManager for mocking Health Connect, TestDispatcher for coroutine testing.</snippet>
      </artifact>
    </docs>
    <code>
      <artifact>
        <path>app/app/build.gradle.kts</path>
        <kind>build-configuration</kind>
        <symbol>jacocoTestReport task</symbol>
        <lines>257-310</lines>
        <reason>JaCoCo configuration for combined unit + instrumentation coverage reporting. Critical for AC #3 SonarQube integration.</reason>
      </artifact>
      <artifact>
        <path>app/app/src/androidTest/java/com/foodie/app/ui/screens/energybalance/EnergyBalanceDashboardDateNavigationTest.kt</path>
        <kind>instrumentation-test</kind>
        <symbol>EnergyBalanceDashboardDateNavigationTest</symbol>
        <lines>1-500</lines>
        <reason>Epic 6 Dashboard UI test with 12 tests covering historical navigation, data display, and real-time updates. Primary test for AC #2 Epic 6 flow coverage.</reason>
      </artifact>
      <artifact>
        <path>app/app/src/androidTest/java/com/foodie/app/ui/screens/settings/SettingsScreenTest.kt</path>
        <kind>instrumentation-test</kind>
        <symbol>SettingsScreenTest</symbol>
        <lines>1-300</lines>
        <reason>Settings screen UI test covering Epic 5/6 user profile management. Tests Hilt integration, Compose UI, and ViewModel state management patterns.</reason>
      </artifact>
      <artifact>
        <path>app/app/src/androidTest/java/com/foodie/app/data/healthconnect/HealthConnectIntegrationTest.kt</path>
        <kind>instrumentation-test</kind>
        <symbol>HealthConnectIntegrationTest</symbol>
        <lines>1-400</lines>
        <reason>Health Connect integration test validating nutrition data read/write operations. Core data persistence layer test for regression protection.</reason>
      </artifact>
      <artifact>
        <path>app/app/src/androidTest/java/com/foodie/app/data/worker/AnalyzeMealWorkerForegroundTest.kt</path>
        <kind>instrumentation-test</kind>
        <symbol>AnalyzeMealWorkerForegroundTest</symbol>
        <lines>1-300</lines>
        <reason>WorkManager background processing test for Epic 2 meal analysis flow. Tests WorkManager + Hilt integration, critical for reliability validation.</reason>
      </artifact>
      <artifact>
        <path>app/app/src/androidTest/java/com/foodie/app/HiltTestRunner.kt</path>
        <kind>test-infrastructure</kind>
        <symbol>HiltTestRunner</symbol>
        <lines>1-50</lines>
        <reason>Custom test runner enabling Hilt dependency injection in instrumentation tests. Required for all 23 test files.</reason>
      </artifact>
      <artifact>
        <path>app/app/src/test/java/com/foodie/app/domain/model/EnergyBalanceTest.kt</path>
        <kind>unit-test</kind>
        <symbol>EnergyBalanceTest</symbol>
        <lines>1-200</lines>
        <reason>Epic 6 domain model unit test validating energy balance calculations. Complements instrumentation tests for full Epic 6 coverage.</reason>
      </artifact>
      <artifact>
        <path>sonar-project.properties</path>
        <kind>configuration</kind>
        <symbol>sonar.coverage.jacoco.xmlReportPaths</symbol>
        <lines>1-50</lines>
        <reason>SonarQube configuration specifying JaCoCo XML report path. Critical for AC #3 coverage metric visibility in SonarQube.</reason>
      </artifact>
    </code>
    <dependencies>
      <android>
        <package name="androidx.test.ext:junit" version="1.1.5">JUnit4 test framework for instrumentation tests</package>
        <package name="androidx.test.espresso:espresso-core" version="3.5.1">UI testing framework for Android</package>
        <package name="androidx.compose.ui:ui-test-junit4" version="2024.10.01">Compose UI testing library with test rules and matchers</package>
        <package name="com.google.truth:truth" version="1.1.5">Fluent assertion library for readable test assertions</package>
        <package name="com.google.dagger:hilt-android-testing" version="2.51.1">Hilt testing library for dependency injection in tests</package>
        <package name="androidx.work:work-testing" version="2.9.0">WorkManager testing library for background task validation</package>
        <package name="io.mockk:mockk-android" version="1.13.8">Mocking library for Android instrumentation tests</package>
        <package name="org.jacoco:jacoco-gradle-plugin" version="0.8.11">Code coverage plugin for unit and instrumentation tests</package>
      </android>
    </dependencies>
  </artifacts>

  <constraints>
**Testing Architecture (from architecture.md):**
- All instrumentation tests use HiltTestRunner for dependency injection
- Compose tests use createComposeRule() for UI testing
- Health Connect operations use FakeHealthConnectManager for mocking
- Background tasks use TestDispatcher and WorkManager testing library
- Test naming convention: descriptive with spaces (Android convention)

**SonarQube Integration Requirements (from definition-of-done.md):**
- JaCoCo must merge unit test coverage (test task) + instrumentation test coverage (connectedDebugAndroidTest task)
- XML report path configured in sonar-project.properties: app/build/reports/jacoco/jacocoTestReport/jacocoTestReport.xml
- Coverage thresholds: 80%+ line coverage target, identify critical uncovered code
- Quality gate: 0 BLOCKER, 0 CRITICAL, &lt;5 new MAJOR issues

**Test Reliability Standards:**
- No flaky tests (100% pass rate over 3 consecutive runs)
- No test pollution (tests can run in any order)
- Proper setup/teardown in all test files
- Total execution time &lt; 5 minutes (AC #1, AC #7)
- Individual test execution time &lt; 30 seconds (AC #7)

**Epic 6 Test Coverage Requirements (from tech-spec-epic-6.md):**
- User profile management (Story 6-1): Settings UI tests
- BMR calculation (Story 6-2): Domain model unit tests
- NEAT calculation (Story 6-3): Domain model unit tests
- Active energy (Story 6-4): Health Connect integration tests
- TDEE calculation (Story 6-5): Domain model unit tests
- Dashboard display (Story 6-6): Dashboard UI instrumentation tests
- Historical navigation (Story 6-7): Dashboard navigation instrumentation tests

**Known Test Files (23 total from story file):**
1. EnergyBalanceDashboardDateNavigationTest.kt (12 tests) - Epic 6
2. SettingsScreenTest.kt - Epic 5/6
3. SettingsNavigationTest.kt - Epic 5
4. ApiConfigurationInstrumentationTest.kt - Epic 5
5. MealListScreenTest.kt - Epic 3
6. MealListScreenDeleteTest.kt - Epic 3
7. MealDetailScreenTest.kt - Epic 3
8. CapturePhotoEdgeCasesTest.kt - Epic 2
9. MealCaptureWidgetInstrumentationTest.kt - Epic 2
10. HealthConnectIntegrationTest.kt - Epic 1/2
11. HealthConnectUpdateIntegrationTest.kt - Epic 3
12. HealthConnectPermissionFlowTest.kt - Epic 4
13. HealthConnectUnavailableDialogTest.kt - Epic 4
14. HealthConnectHiltTest.kt - Epic 1
15. AnalyzeMealWorkerForegroundTest.kt - Epic 2
16. MealAnalysisForegroundNotifierTest.kt - Epic 2
17. PhotoCleanupWorkerTest.kt - Epic 4
18. FoodieApplicationWorkManagerTest.kt - Epic 2
19. MealRepositoryDeleteIntegrationTest.kt - Epic 3
20. NutritionAnalysisRepositoryImplIntegrationTest.kt - Epic 2
21. CredentialMigrationTest.kt - Epic 5
22. PhotoManagerCacheStatsTest.kt - Epic 4
23. ExampleInstrumentedTest.kt (cleanup candidate - may be removed)
  </constraints>

  <interfaces>
**JaCoCo Gradle Task Interface (app/build.gradle.kts):**
```kotlin
tasks.register&lt;JacocoReport&gt;("jacocoTestReport") {
    dependsOn("testDebugUnitTest", "createDebugCoverageReport")

    reports {
        xml.required.set(true)
        html.required.set(true)
    }

    // Combines unit test + instrumentation test coverage
    executionData.setFrom(files(
        "jacoco/testDebugUnitTest.exec",
        "outputs/code_coverage/debugAndroidTest/connected/**/*.ec"
    ))
}
```

**Test Execution Commands:**
```bash
# Run all instrumentation tests
./gradlew connectedDebugAndroidTest

# Run specific test file
./gradlew connectedDebugAndroidTest -Pandroid.testInstrumentationRunnerArguments.class=com.foodie.app.ui.screens.energybalance.EnergyBalanceDashboardDateNavigationTest

# Generate combined coverage (unit + instrumentation)
./gradlew clean test connectedDebugAndroidTest jacocoTestReport

# Upload to SonarQube
./gradlew sonar
```

**SonarQube Configuration (sonar-project.properties):**
```properties
sonar.coverage.jacoco.xmlReportPaths=app/build/reports/jacoco/jacocoTestReport/jacocoTestReport.xml
```

**HiltTestRunner (required for all instrumentation tests):**
```kotlin
// app/build.gradle.kts
defaultConfig {
    testInstrumentationRunner = "com.foodie.app.HiltTestRunner"
}
```

**Compose Test Pattern (from existing tests):**
```kotlin
@HiltAndroidTest
class ExampleInstrumentationTest {
    @get:Rule(order = 0)
    val hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule&lt;ComponentActivity&gt;()

    @Before
    fun setup() {
        hiltRule.inject()
    }

    @Test
    fun exampleTest() {
        composeTestRule.setContent { /* UI under test */ }
        composeTestRule.onNodeWithText("Example").assertExists()
    }
}
```
  </interfaces>

  <tests>
    <standards>
Testing follows Android instrumentation testing best practices with Hilt dependency injection, Compose UI testing, and JaCoCo code coverage reporting. All tests use HiltTestRunner, follow descriptive naming conventions, and maintain strict isolation (no test pollution). Unit tests cover domain logic (ViewModels, Repositories, Use Cases) while instrumentation tests validate UI flows, Health Connect integration, and WorkManager background processing. Coverage is measured via JaCoCo with combined unit + instrumentation reports uploaded to SonarQube for quality gate validation.
    </standards>
    <locations>
- app/app/src/test/java/com/foodie/app/** (unit tests)
- app/app/src/androidTest/java/com/foodie/app/** (instrumentation tests)
- app/build/reports/tests/testDebugUnitTest/index.html (unit test reports)
- app/build/reports/androidTests/connected/debug/index.html (instrumentation test reports)
- app/build/reports/jacoco/jacocoTestReport/html/index.html (coverage reports)
    </locations>
    <ideas>
**AC #1 Test Ideas (Test Suite Execution):**
- Verify all 23 instrumentation test files execute via ./gradlew connectedDebugAndroidTest
- Measure total execution time and validate &lt; 5 minutes
- Run test suite 3 consecutive times to identify flaky tests
- Document any failures and root cause analysis

**AC #2 Test Ideas (Epic 6 User Flow Coverage):**
- Map EnergyBalanceDashboardDateNavigationTest.kt to Stories 6-6 and 6-7
- Map SettingsScreenTest.kt to Story 6-1 user profile management
- Verify domain model unit tests cover Stories 6-2, 6-3, 6-5 (BMR, NEAT, TDEE)
- Map HealthConnectIntegrationTest.kt to Story 6-4 active energy queries
- Create test coverage matrix documenting story-to-test mapping

**AC #3 Test Ideas (SonarQube Integration):**
- Verify JaCoCo task executes: ./gradlew jacocoTestReport
- Check XML report exists at app/build/reports/jacoco/jacocoTestReport/jacocoTestReport.xml
- Validate instrumentation test coverage included in report (check .ec files merged)
- Run ./gradlew sonar and verify dashboard displays combined coverage
- Compare coverage percentage before/after instrumentation test inclusion

**AC #5 Test Ideas (Test Organization):**
- Review all 23 test files for naming convention consistency
- Verify logical grouping: ui/screens/*, data/healthconnect/*, data/worker/*
- Check for duplicate test coverage (e.g., same scenario tested in multiple files)
- Validate test method names follow descriptive convention

**AC #6 Test Ideas (Test Data and Dependencies):**
- Audit @Before/@After methods in all test files for proper setup/teardown
- Verify HiltAndroidRule used correctly in all @HiltAndroidTest files
- Check FakeHealthConnectManager usage for Health Connect mocking
- Run tests in random order to detect interdependencies: --tests '*' --rerun-tasks

**AC #7 Test Ideas (Performance Validation):**
- Profile test execution with ./gradlew connectedDebugAndroidTest --profile
- Identify tests taking > 10 seconds from HTML report
- Optimize slow tests (reduce Thread.sleep, use composeTestRule.waitForIdle)
- Document performance baseline for regression tracking

**AC #8 Test Ideas (Coverage Gaps):**
- Generate JaCoCo HTML report and review uncovered classes/methods
- Identify critical code paths without test coverage (e.g., error handling, edge cases)
- Document coverage gaps in REGRESSION_TESTING.md with recommendations
- Define acceptable threshold: 80%+ line coverage for core business logic
    </ideas>
  </tests>
</story-context>
